This is Info file perl.info, produced by Makeinfo-1.64 from the input
file Pmaster.texi.


File: perl.info,  Node: perlre,  Next: perlrun,  Prev: perlop,  Up: Top

NAME
====

perlre - Perl regular expressions

DESCRIPTION
===========

This page describes the syntax of regular expressions in Perl.  For a
description of how to use regular expressions in matching operations,
plus various examples of the same, see m// and s/// in *Note Perlop:
perlop.

The matching operations can have various modifiers.  The modifiers
which relate to the interpretation of the regular expression inside are
listed below.  For the modifiers that alter the behaviour of the
operation, see `"m', *Note Perlop: perlop, and `"s', *Note Perlop:
perlop,.

i
     Do case-insensitive pattern matching.

     If `use locale' is in effect, the case map is taken from the
     current locale.  See *Note Perllocale: perllocale.

m
     Treat string as multiple lines.  That is, change "^" and "$" from
     matching at only the very start or end of the string to the start
     or end of any line anywhere within the string,

s
     Treat string as single line.  That is, change "." to match any
     character whatsoever, even a newline, which it normally would not
     match.

x
     Extend your pattern's legibility by permitting whitespace and
     comments.

These are usually written as "the `/x' modifier", even though the
delimiter in question might not actually be a slash.  In fact, any of
these modifiers may also be embedded within the regular expression
itself using the new `(?...)' construct.  See below.

The `/x' modifier itself needs a little more explanation.  It tells the
regular expression parser to ignore whitespace that is neither
backslashed nor within a character class.  You can use this to break up
your regular expression into (slightly) more readable parts.  The `#'
character is also treated as a metacharacter introducing a comment,
just as in ordinary Perl code.  This also means that if you want real
whitespace or `#' characters in the pattern that you'll have to either
escape them or encode them using octal or hex escapes.  Taken together,
these features go a long way towards making Perl's regular expressions
more readable.  See the C comment deletion code in *Note Perlop: perlop.

Regular Expressions
-------------------

The patterns used in pattern matching are regular expressions such as
those supplied in the Version 8 regexp routines.  (In fact, the
routines are derived (distantly) from Henry Spencer's freely
redistributable reimplementation of the V8 routines.) See `Version 8
Regular Expressions' in this node for details.

In particular the following metacharacters have their standard
*egrep*-ish meanings:

     \       Quote the next metacharacter
     ^       Match the beginning of the line
     .       Match any character (except newline)
     $       Match the end of the line (or before newline at the end)
     |       Alternation
     ()      Grouping
     []      Character class

By default, the "^" character is guaranteed to match at only the
beginning of the string, the "$" character at only the end (or before
the newline at the end) and Perl does certain optimizations with the
assumption that the string contains only one line.  Embedded newlines
will not be matched by "^" or "$".  You may, however, wish to treat a
string as a multi-line buffer, such that the "^" will match after any
newline within the string, and "$" will match before any newline.  At
the cost of a little more overhead, you can do this by using the /m
modifier on the pattern match operator.  (Older programs did this by
setting $*, but this practice is now deprecated.)

To facilitate multi-line substitutions, the "." character never matches
a newline unless you use the `/s' modifier, which in effect tells Perl
to pretend the string is a single line-even if it isn't.  The `/s'
modifier also overrides the setting of $*, in case you have some (badly
behaved) older code that sets it in another module.

The following standard quantifiers are recognized:

     *          Match 0 or more times
     +          Match 1 or more times
     ?          Match 1 or 0 times
     {n}    Match exactly n times
     {n,}   Match at least n times
     {n,m}  Match at least n but not more than m times

(If a curly bracket occurs in any other context, it is treated as a
regular character.)  The "*" modifier is equivalent to `{0,}', the "+"
modifier to `{1,}', and the "?" modifier to `{0,1}'.  n and m are
limited to integral values less than 65536.

By default, a quantified subpattern is "greedy", that is, it will match
as many times as possible (given a particular starting location) while
still allowing the rest of the pattern to match.  If you want it to
match the minimum number of times possible, follow the quantifier with
a "?".  Note that the meanings don't change, just the "greediness":

     *?         Match 0 or more times
     +?         Match 1 or more times
     ??         Match 0 or 1 time
     {n}?   Match exactly n times
     {n,}?  Match at least n times
     {n,m}? Match at least n but not more than m times

Because patterns are processed as double quoted strings, the following
also work:

     \t              tab                   (HT, TAB)
     \n              newline               (LF, NL)
     \r              return                (CR)
     \f              form feed             (FF)
     \a              alarm (bell)          (BEL)
     \e              escape (think troff)  (ESC)
     \033    octal char (think of a PDP-11)
     \x1B    hex char
     \c[             control char
     \l              lowercase next char (think vi)
     \u              uppercase next char (think vi)
     \L              lowercase till \E (think vi)
     \U              uppercase till \E (think vi)
     \E              end case modification (think vi)
     \Q              quote regexp metacharacters till \E

If `use locale' is in effect, the case map used by `\l', `\L', `\u' and
<\U> is taken from the current locale.  See *Note Perllocale:
perllocale.

In addition, Perl defines the following:

     \w      Match a "word" character (alphanumeric plus "_")
     \W      Match a non-word character
     \s      Match a whitespace character
     \S      Match a non-whitespace character
     \d      Match a digit character
     \D      Match a non-digit character

Note that `\w' matches a single alphanumeric character, not a whole
word.  To match a word you'd need to say `\w+'.  If `use locale' is in
effect, the list of alphabetic characters generated by `\w' is taken
from the current locale.  See *Note Perllocale: perllocale. You may use
`\w', `\W', `\s', `\S', `\d', and `\D' within character classes (though
not as either end of a range).

Perl defines the following zero-width assertions:

     \b      Match a word boundary
     \B      Match a non-(word boundary)
     \A      Match at only beginning of string
     \Z      Match at only end of string (or before newline at the end)
     \G      Match only where previous m//g left off (works only with /g)

A word boundary (`\b') is defined as a spot between two characters that
has a `\w' on one side of it and a `\W' on the other side of it (in
either order), counting the imaginary characters off the beginning and
end of the string as matching a `\W'.  (Within character classes `\b'
represents backspace rather than a word boundary.)  The `\A' and `\Z'
are just like "^" and "$" except that they won't match multiple times
when the `/m' modifier is used, while "^" and "$" will match at every
internal line boundary.  To match the actual end of the string, not
ignoring newline, you can use `\Z(?!\n)'.  The `\G' assertion can be
used to chain global matches (using `m//g'), as described in `"Regexp
Quote-Like Operators"', *Note Perlop: perlop.

It is also useful when writing `lex'-like scanners, when you have
several regexps which you want to match against consequent substrings
of your string, see the previous reference.  The actual location where
`\G' will match can also be influenced by using `pos()' as an lvalue.
See `pos', *Note Perlfunc: perlfunc.

When the bracketing construct `( ... )' is used, \<digit> matches the
digit'th substring.  Outside of the pattern, always use "$" instead of
"\" in front of the digit.  (While the \<digit> notation can on rare
occasion work outside the current pattern, this should not be relied
upon.  See the WARNING below.) The scope of $<digit> (and `$`', $&, and
`$'') extends to the end of the enclosing BLOCK or eval string, or to
the next successful pattern match, whichever comes first.  If you want
to use parentheses to delimit a subpattern (e.g., a set of
alternatives) without saving it as a subpattern, follow the ( with a ?:.

You may have as many parentheses as you wish.  If you have more than 9
substrings, the variables $10, $11, ... refer to the corresponding
substring.  Within the pattern, \10, \11, etc. refer back to substrings
if there have been at least that many left parentheses before the
backreference.  Otherwise (for backward compatibility) \10 is the same
as \010, a backspace, and \11 the same as \011, a tab.  And so on.  (\1
through \9 are always backreferences.)

$+ returns whatever the last bracket match matched.  $& returns the
entire matched string.  ($0 used to return the same thing, but not any
more.)  `$`' returns everything before the matched string.  `$'' returns
everything after the matched string.  Examples:

     s/^([^ ]*) *([^ ]*)/$2 $1/;     # swap first two words
     
     if (/Time: (..):(..):(..)/) {
             $hours = $1;
             $minutes = $2;
             $seconds = $3;
     }

Once perl sees that you need one of $&, `$`' or `$'' anywhere in the
program, it has to provide them on each and every pattern match.  This
can slow your program down.  The same mechanism that handles these
provides for the use of $1, $2, etc., so you pay the same price for
each regexp that contains capturing parentheses. But if you never use
$&, etc., in your script, then regexps *without* capturing parentheses
won't be penalized. So avoid $&, $', and $` if you can, but if you
can't (and some algorithms really appreciate them), once you've used
them once, use them at will, because you've already paid the price.

You will note that all backslashed metacharacters in Perl are
alphanumeric, such as `\b', `\w', `\n'.  Unlike some other regular
expression languages, there are no backslashed symbols that aren't
alphanumeric.  So anything that looks like \\, \(, \), \<, \>, \{, or
\} is always interpreted as a literal character, not a metacharacter.
This makes it simple to quote a string that you want to use for a
pattern but that you are afraid might contain metacharacters.  Quote
simply all the non-alphanumeric characters:

     $pattern =~ s/(\W)/\\$1/g;

You can also use the builtin quotemeta() function to do this.  An even
easier way to quote metacharacters right in the match operator is to say

     /$unquoted\Q$quoted\E$unquoted/

Perl defines a consistent extension syntax for regular expressions.
The syntax is a pair of parentheses with a question mark as the first
thing within the parentheses (this was a syntax error in older versions
of Perl).  The character after the question mark gives the function of
the extension.  Several extensions are already supported:

(?#text)
     A comment.  The text is ignored.  If the `/x' switch is used to
     enable whitespace formatting, a simple `#' will suffice.

(?:regexp)
     This groups things like "()" but doesn't make backreferences like
     "()" does.  So

          split(/\b(?:a|b|c)\b/)

     is like

          split(/\b(a|b|c)\b/)

     but doesn't spit out extra fields.

(?=regexp)
     A zero-width positive lookahead assertion.  For example,
     `/\w+(?=\t)/' matches a word followed by a tab, without including
     the tab in $&.

(?!regexp)
     A zero-width negative lookahead assertion.  For example
     `/foo(?!bar)/' matches any occurrence of "foo" that isn't followed
     by "bar".  Note however that lookahead and lookbehind are NOT the
     same thing.  You cannot use this for lookbehind: `/(?!foo)bar/'
     will not find an occurrence of "bar" that is preceded by something
     which is not "foo".  That's because the `(?!foo)' is just saying
     that the next thing cannot be "foo"-and it's not, it's a "bar", so
     "foobar" will match.  You would have to do something like
     `/(?!foo)...bar/' for that.   We say "like" because there's the
     case of your "bar" not having three characters before it.  You
     could cover that this way: `/(?:(?!foo)...|^..?)bar/'.  Sometimes
     it's still easier just to say:

          if (/foo/ && $` =~ /bar$/)

(?imsx)
     One or more embedded pattern-match modifiers.  This is particularly
     useful for patterns that are specified in a table somewhere, some
     of which want to be case sensitive, and some of which don't.  The
     case insensitive ones need to include merely `(?i)' at the front
     of the pattern.  For example:

          $pattern = "foobar";
          if ( /$pattern/i )
          
          # more flexible:
          
          $pattern = "(?i)foobar";
          if ( /$pattern/ )

The specific choice of question mark for this and the new minimal
matching construct was because 1) question mark is pretty rare in older
regular expressions, and 2) whenever you see one, you should stop and
"question" exactly what is going on.  That's psychology...

Backtracking
------------

A fundamental feature of regular expression matching involves the notion
called *backtracking*.  which is used (when needed) by all regular
expression quantifiers, namely *, `*?', `+', `+?', `{n,m}', and
`{n,m}?'.

For a regular expression to match, the *entire* regular expression must
match, not just part of it.  So if the beginning of a pattern
containing a quantifier succeeds in a way that causes later parts in
the pattern to fail, the matching engine backs up and recalculates the
beginning part-that's why it's called backtracking.

Here is an example of backtracking:  Let's say you want to find the
word following "foo" in the string "Food is on the foo table.":

     $_ = "Food is on the foo table.";
     if ( /\b(foo)\s+(\w+)/i ) {
             print "$2 follows $1.\n";
     }

When the match runs, the first part of the regular expression
(`\b(foo)') finds a possible match right at the beginning of the
string, and loads up $1 with "Foo".  However, as soon as the matching
engine sees that there's no whitespace following the "Foo" that it had
saved in $1, it realizes its mistake and starts over again one
character after where it had the tentative match.  This time it goes
all the way until the next occurrence of "foo". The complete regular
expression matches this time, and you get the expected output of "table
follows foo."

Sometimes minimal matching can help a lot.  Imagine you'd like to match
everything between "foo" and "bar".  Initially, you write something
like this:

     $_ =  "The food is under the bar in the barn.";
     if ( /foo(.*)bar/ ) {
             print "got <$1>\n";
     }

Which perhaps unexpectedly yields:

     got <d is under the bar in the >

That's because `.*' was greedy, so you get everything between the
*first* "foo" and the last "bar".  In this case, it's more effective to
use minimal matching to make sure you get the text between a "foo" and
the first "bar" thereafter.

     if ( /foo(.*?)bar/ ) { print "got <$1>\n" }
       got <d is under the >

Here's another example: let's say you'd like to match a number at the
end of a string, and you also want to keep the preceding part the match.
So you write this:

     $_ = "I have 2 numbers: 53147";
     if ( /(.*)(\d*)/ ) {                           # Wrong!
             print "Beginning is <$1>, number is <$2>.\n";
     }

That won't work at all, because `.*' was greedy and gobbled up the
whole string. As `\d*' can match on an empty string the complete
regular expression matched successfully.

     Beginning is <I have 2 numbers: 53147>, number is <>.

Here are some variants, most of which don't work:

     $_ = "I have 2 numbers: 53147";
     @pats = qw{
             (.*)(\d*)
             (.*)(\d+)
             (.*?)(\d*)
             (.*?)(\d+)
             (.*)(\d+)$
             (.*?)(\d+)$
             (.*)\b(\d+)$
             (.*\D)(\d+)$
     };
     
     for $pat (@pats) {
             printf "%-12s ", $pat;
             if ( /$pat/ ) {
                 print "<$1> <$2>\n";
             } else {
                 print "FAIL\n";
             }
     }

That will print out:

     (.*)(\d*)    <I have 2 numbers: 53147> <>
     (.*)(\d+)    <I have 2 numbers: 5314> <7>
     (.*?)(\d*)   <> <>
     (.*?)(\d+)   <I have > <2>
     (.*)(\d+)$   <I have 2 numbers: 5314> <7>
     (.*?)(\d+)$  <I have 2 numbers: > <53147>
     (.*)\b(\d+)$ <I have 2 numbers: > <53147>
     (.*\D)(\d+)$ <I have 2 numbers: > <53147>

As you see, this can be a bit tricky.  It's important to realize that a
regular expression is merely a set of assertions that gives a definition
of success.  There may be 0, 1, or several different ways that the
definition might succeed against a particular string.  And if there are
multiple ways it might succeed, you need to understand backtracking to
know which variety of success you will achieve.

When using lookahead assertions and negations, this can all get even
tricker.  Imagine you'd like to find a sequence of non-digits not
followed by "123".  You might try to write that as

     $_ = "ABC123";
     if ( /^\D*(?!123)/ ) {                         # Wrong!
         print "Yup, no 123 in $_\n";
     }

But that isn't going to match; at least, not the way you're hoping.  It
claims that there is no 123 in the string.  Here's a clearer picture of
why it that pattern matches, contrary to popular expectations:

     $x = 'ABC123' ;
     $y = 'ABC445' ;
     
     print "1: got $1\n" if $x =~ /^(ABC)(?!123)/ ;
     print "2: got $1\n" if $y =~ /^(ABC)(?!123)/ ;
     
     print "3: got $1\n" if $x =~ /^(\D*)(?!123)/ ;
     print "4: got $1\n" if $y =~ /^(\D*)(?!123)/ ;

This prints

     2: got ABC
     3: got AB
     4: got ABC

You might have expected test 3 to fail because it seems to a more
general purpose version of test 1.  The important difference between
them is that test 3 contains a quantifier (`\D*') and so can use
backtracking, whereas test 1 will not.  What's happening is that you've
asked "Is it true that at the start of $x, following 0 or more
non-digits, you have something that's not 123?"  If the pattern matcher
had let `\D*' expand to "ABC", this would have caused the whole pattern
to fail.  The search engine will initially match `\D*' with "ABC".
Then it will try to match `(?!123' with "123" which, of course, fails.
But because a quantifier (`\D*') has been used in the regular
expression, the search engine can backtrack and retry the match
differently in the hope of matching the complete regular expression.

Well now, the pattern really, *really* wants to succeed, so it uses the
standard regexp back-off-and-retry and lets `\D*' expand to just "AB"
this time.  Now there's indeed something following "AB" that is not
"123".  It's in fact "C123", which suffices.

We can deal with this by using both an assertion and a negation.  We'll
say that the first part in $1 must be followed by a digit, and in fact,
it must also be followed by something that's not "123".  Remember that
the lookaheads are zero-width expressions-they only look, but don't
consume any of the string in their match.  So rewriting this way
produces what you'd expect; that is, case 5 will fail, but case 6
succeeds:

     print "5: got $1\n" if $x =~ /^(\D*)(?=\d)(?!123)/ ;
     print "6: got $1\n" if $y =~ /^(\D*)(?=\d)(?!123)/ ;
     
     6: got ABC

In other words, the two zero-width assertions next to each other work
like they're ANDed together, just as you'd use any builtin assertions:
`/^$/' matches only if you're at the beginning of the line AND the end
of the line simultaneously.  The deeper underlying truth is that
juxtaposition in regular expressions always means AND, except when you
write an explicit OR using the vertical bar.  `/ab/' means match "a"
AND (then) match "b", although the attempted matches are made at
different positions because "a" is not a zero-width assertion, but a
one-width assertion.

One warning: particularly complicated regular expressions can take
exponential time to solve due to the immense number of possible ways
they can use backtracking to try match.  For example this will take a
very long time to run

     /((a{0,5}){0,5}){0,5}/

And if you used *'s instead of limiting it to 0 through 5 matches, then
it would take literally forever-or until you ran out of stack space.

Version 8 Regular Expressions
-----------------------------

In case you're not familiar with the "regular" Version 8 regexp
routines, here are the pattern-matching rules not described above.

Any single character matches itself, unless it is a *metacharacter*
with a special meaning described here or above.  You can cause
characters which normally function as metacharacters to be interpreted
literally by prefixing them with a "\" (e.g., "\." matches a ".", not
any character; "\\" matches a "\").  A series of characters matches that
series of characters in the target string, so the pattern `blurfl'
would match "blurfl" in the target string.

You can specify a character class, by enclosing a list of characters in
`[]', which will match any one of the characters in the list.  If the
first character after the "[" is "^", the class matches any character
not in the list.  Within a list, the "-" character is used to specify a
range, so that `a-z' represents all the characters between "a" and "z",
inclusive.

Characters may be specified using a metacharacter syntax much like that
used in C: "\n" matches a newline, "\t" a tab, "\r" a carriage return,
"\f" a form feed, etc.  More generally, \*nnn*, where *nnn* is a string
of octal digits, matches the character whose ASCII value is *nnn*.
Similarly, \x*nn*, where *nn* are hexadecimal digits, matches the
character whose ASCII value is *nn*. The expression \cx matches the
ASCII character control-x.  Finally, the "." metacharacter matches any
character except "\n" (unless you use `/s').

You can specify a series of alternatives for a pattern using "|" to
separate them, so that `fee|fie|foe' will match any of "fee", "fie", or
"foe" in the target string (as would `f(e|i|o)e').  Note that the first
alternative includes everything from the last pattern delimiter ("(",
"[", or the beginning of the pattern) up to the first "|", and the last
alternative contains everything from the last "|" to the next pattern
delimiter.  For this reason, it's common practice to include
alternatives in parentheses, to minimize confusion about where they
start and end.  Note however that "|" is interpreted as a literal with
square brackets, so if you write `[fee|fie|foe]' you're really only
matching `[feio|]'.

Within a pattern, you may designate subpatterns for later reference by
enclosing them in parentheses, and you may refer back to the nth
subpattern later in the pattern using the metacharacter \n.
Subpatterns are numbered based on the left to right order of their
opening parenthesis.  Note that a backreference matches whatever
actually matched the subpattern in the string being examined, not the
rules for that subpattern.  Therefore, `(0|0x)\d*\s\1\d*' will match
"0x1234 0x4321",but not "0x1234 01234", because subpattern 1 actually
matched "0x", even though the rule `0|0x' could potentially match the
leading 0 in the second number.

WARNING on \1 vs $1
-------------------

Some people get too used to writing things like

     $pattern =~ s/(\W)/\\\1/g;

This is grandfathered for the RHS of a substitute to avoid shocking the
*sed* addicts, but it's a dirty habit to get into.  That's because in
PerlThink, the righthand side of a s/// is a double-quoted string.  \1
in the usual double-quoted string means a control-A.  The customary Unix
meaning of \1 is kludged in for s///.  However, if you get into the
habit of doing that, you get yourself into trouble if you then add an
`/e' modifier.

     s/(\d+)/ \1 + 1 /eg;

Or if you try to do

     s/(\d+)/\1000/;

You can't disambiguate that by saying `\{1}000', whereas you can fix it
with `${1}000'.  Basically, the operation of interpolation should not
be confused with the operation of matching a backreference.  Certainly
they mean two different things on the *left* side of the s///.

SEE ALSO
--------

"Mastering Regular Expressions" (see *Note Perlbook: perlbook,) by
Jeffrey Friedl.


File: perl.info,  Node: perlrun,  Next: perlfunc,  Prev: perlre,  Up: Top

NAME
====

perlrun - how to execute the Perl interpreter

SYNOPSIS
========

perl [ -sTuU ] [ -hv ] [ -V[:configvar] ] [ -cw ] [ -d[:debugger] ] [
-D[number/list] ] [ -pna ] [ -Fpattern ] [ -l[octal] ] [ -0[octal] ] [
-Idir ] [ -m[-]module ] [ -M[-]'module...' ] [ -P ] [ -S ] [ -x[dir] ]
[ -i[extension] ] [ -e 'command' ] [ - ] [ programfile ] [ argument ]...

DESCRIPTION
===========

Upon startup, Perl looks for your script in one of the following places:

  1. Specified line by line via -e switches on the command line.

  2. Contained in the file specified by the first filename on the
     command line.  (Note that systems supporting the #! notation
     invoke interpreters this way.)

  3. Passed in implicitly via standard input.  This works only if there
     are no filename arguments-to pass arguments to a STDIN script you
     must explicitly specify a "-" for the script name.

     With methods 2 and 3, Perl starts parsing the input file from the
beginning, unless you've specified a -x switch, in which case it scans
for the first line starting with #! and containing the word "perl", and
starts there instead.  This is useful for running a script embedded in
a larger message.  (In this case you would indicate the end of the
script using the `__END__' token.)

The #! line is always examined for switches as the line is being
parsed.  Thus, if you're on a machine that allows only one argument
with the #! line, or worse, doesn't even recognize the #! line, you
still can get consistent switch behavior regardless of how Perl was
invoked, even if -x was used to find the beginning of the script.

Because many operating systems silently chop off kernel interpretation
of the #! line after 32 characters, some switches may be passed in on
the command line, and some may not; you could even get a "-" without its
letter, if you're not careful.  You probably want to make sure that all
your switches fall either before or after that 32 character boundary.
Most switches don't actually care if they're processed redundantly, but
getting a - instead of a complete switch could cause Perl to try to
execute standard input instead of your script.  And a partial -I switch
could also cause odd results.

Parsing of the #! switches starts wherever "perl" is mentioned in the
line.  The sequences "-*" and "- " are specifically ignored so that you
could, if you were so inclined, say

     #!/bin/sh -- # -*- perl -*- -p
     eval 'exec /usr/bin/perl $0 -S ${1+"$@"}'
         if $running_under_some_shell;

to let Perl see the -p switch.

If the #! line does not contain the word "perl", the program named after
the #! is executed instead of the Perl interpreter.  This is slightly
bizarre, but it helps people on machines that don't do #!, because they
can tell a program that their SHELL is /usr/bin/perl, and Perl will then
dispatch the program to the correct interpreter for them.

After locating your script, Perl compiles the entire script to an
internal form.  If there are any compilation errors, execution of the
script is not attempted.  (This is unlike the typical shell script,
which might run part-way through before finding a syntax error.)

If the script is syntactically correct, it is executed.  If the script
runs off the end without hitting an exit() or die() operator, an
implicit `exit(0)' is provided to indicate successful completion.

#! and quoting on non-Unix systems
----------------------------------

Unix's #! technique can be simulated on other systems:

OS/2
     Put

          extproc perl -S -your_switches

     as the first line in `*.cmd' file (-S due to a bug in cmd.exe's
     `extproc' handling).

MS-DOS
     Create a batch file to run your script, and codify it in
     `ALTERNATIVE_SHEBANG' (see the `dosish.h' file in the source
     distribution for more information).

Win95/NT
     The Win95/NT installation, when using the Activeware port of Perl,
     will modify the Registry to associate the .pl extension with the
     perl interpreter.  If you install another port of Perl, including
     the one in the Win32 directory of the Perl distribution, then
     you'll have to modify the Registry yourself.

Macintosh
     Macintosh perl scripts will have the appropriate Creator and Type,
     so that double-clicking them will invoke the perl application.

Command-interpreters on non-Unix systems have rather different ideas on
quoting than Unix shells.  You'll need to learn the special characters
in your command-interpreter (*, `\' and `"' are common) and how to
protect whitespace and these characters to run one-liners (see -e
below).

On some systems, you may have to change single-quotes to double ones,
which you must *NOT* do on Unix or Plan9 systems.  You might also have
to change a single % to a %%.

For example:

     # Unix
     perl -e 'print "Hello world\n"'
     
     # MS-DOS, etc.
     perl -e "print \"Hello world\n\""
     
     # Macintosh
     print "Hello world\n"
      (then Run "Myscript" or Shift-Command-R)
     
     # VMS
     perl -e "print ""Hello world\n"""

The problem is that none of this is reliable: it depends on the command
and it is entirely possible neither works.  If 4DOS was the command
shell, this would probably work better:

     perl -e "print <Ctrl-x>"Hello world\n<Ctrl-x>""

CMD.EXE in Windows NT slipped a lot of standard Unix functionality in
when nobody was looking, but just try to find documentation for its
quoting rules.

Under the Macintosh, it depends which environment you are using.  The
MacPerl shell, or MPW, is much like Unix shells in its support for
several quoting variants, except that it makes free use of the
Macintosh's non-ASCII characters as control characters.

There is no general solution to all of this.  It's just a mess.

Switches
--------

A single-character switch may be combined with the following switch, if
any.

     #!/usr/bin/perl -spi.bak        # same as -s -p -i.bak

Switches include:

-0[*digits*]
     specifies the input record separator ($/) as an octal number.  If
     there are no digits, the null character is the separator.  Other
     switches may precede or follow the digits.  For example, if you
     have a version of *find* which can print filenames terminated by
     the null character, you can say this:

          find . -name '*.bak' -print0 | perl -n0e unlink

     The special value 00 will cause Perl to slurp files in paragraph
     mode.  The value 0777 will cause Perl to slurp files whole because
     there is no legal character with that value.

-a
     turns on autosplit mode when used with a -n or -p.  An implicit
     split command to the @F array is done as the first thing inside the
     implicit while loop produced by the -n or -p.

          perl -ane 'print pop(@F), "\n";'

     is equivalent to

          while (<>) {
                  @F = split(' ');
                  print pop(@F), "\n";
          }

     An alternate delimiter may be specified using -F.

-c
     causes Perl to check the syntax of the script and then exit without
     executing it.  Actually, it *will* execute BEGIN, END, and use
     blocks, because these are considered as occurring outside the
     execution of your program.

-d
     runs the script under the Perl debugger.  See *Note Perldebug:
     perldebug.

*-d:**foo*
     runs the script under the control of a debugging or tracing module
     installed as Devel::foo. E.g., *-d:DProf* executes the script
     using the Devel::DProf profiler.  See *Note Perldebug: perldebug.

-D*number*
-D*list*
     sets debugging flags.  To watch how it executes your script, use
     *-D14*.  (This works only if debugging is compiled into your
     Perl.)  Another nice value is *-D1024*, which lists your compiled
     syntax tree.  And *-D512* displays compiled regular expressions.
     As an alternative specify a list of letters instead of numbers
     (e.g., *-D14* is equivalent to *-Dtls*):

          1  p  Tokenizing and Parsing
          2  s  Stack Snapshots
          4  l  Label Stack Processing
          8  t  Trace Execution
                 16  o  Operator Node Construction
                 32  c  String/Numeric Conversions
                 64  P  Print Preprocessor Command for -P
                128  m  Memory Allocation
                256  f  Format Processing
                512  r  Regular Expression Parsing
               1024  x  Syntax Tree Dump
               2048  u  Tainting Checks
               4096  L  Memory Leaks (not supported anymore)
               8192  H  Hash Dump -- usurps values()
              16384  X  Scratchpad Allocation
              32768  D  Cleaning Up

-e *commandline*
     may be used to enter one line of script.  If -e is given, Perl
     will not look for a script filename in the argument list.
     Multiple -e commands may be given to build up a multi-line script.
     Make sure to use semicolons where you would in a normal program.

-F*pattern*
     specifies the pattern to split on if -a is also in effect.  The
     pattern may be surrounded by `//', `""', or `''', otherwise it
     will be put in single quotes.

-h
     prints a summary of the options.

-i[*extension*]
     specifies that files processed by the C<<>> construct are to be
     edited in-place.  It does this by renaming the input file, opening
     the output file by the original name, and selecting that output
     file as the default for print() statements.  The extension, if
     supplied, is added to the name of the old file to make a backup
     copy.  If no extension is supplied, no backup is made.  From the
     shell, saying

          $ perl -p -i.bak -e "s/foo/bar/; ... "

     is the same as using the script:

          #!/usr/bin/perl -pi.bak
          s/foo/bar/;

     which is equivalent to

          #!/usr/bin/perl
          while (<>) {
                  if ($ARGV ne $oldargv) {
                      rename($ARGV, $ARGV . '.bak');
                      open(ARGVOUT, ">$ARGV");
                      select(ARGVOUT);
                      $oldargv = $ARGV;
                  }
                  s/foo/bar/;
          }
          continue {
                  print;  # this prints to original filename
          }
          select(STDOUT);

     except that the -i form doesn't need to compare $ARGV to $oldargv
     to know when the filename has changed.  It does, however, use
     ARGVOUT for the selected filehandle.  Note that STDOUT is restored
     as the default output filehandle after the loop.

     You can use eof without parenthesis to locate the end of each
     input file, in case you want to append to each file, or reset line
     numbering (see example in `eof', *Note Perlfunc: perlfunc,).

-I*directory*
     Directories specified by -I are prepended to the search path for
     modules (`@INC'), and also tells the C preprocessor where to
     search for include files.  The C preprocessor is invoked with -P;
     by default it searches /usr/include and /usr/lib/perl.

-l[*octnum*]
     enables automatic line-ending processing.  It has two effects:
     first, it automatically chomps "$/" (the input record separator)
     when used with -n or -p, and second, it assigns "$\" (the output
     record separator) to have the value of *octnum* so that any print
     statements will have that separator added back on.  If *octnum* is
     omitted, sets "$\" to the current value of "$/".  For instance, to
     trim lines to 80 columns:

          perl -lpe 'substr($_, 80) = ""'

     Note that the assignment `$\ = $/' is done when the switch is
     processed, so the input record separator can be different than the
     output record separator if the -l switch is followed by a -0
     switch:

          gnufind / -print0 | perl -ln0e 'print "found $_" if -p'

     This sets $\ to newline and then sets $/ to the null character.

-m[-]*module*
-M[-]*module*
-M[-]*'module ...'*
*-[mM]*[-]*module=arg[,arg]...*
     -m*module* executes use *module* `();' before executing your
     script.

     -M*module* executes use *module* `;' before executing your script.
     You can use quotes to add extra code after the module name, e.g.,
     `-M'module qw(foo bar)''.

     If the first character after the -M or -m is a dash (-) then the
     'use' is replaced with 'no'.

     A little builtin syntactic sugar means you can also say
     `-mmodule=foo,bar' or `-Mmodule=foo,bar' as a shortcut for
     `-M'module qw(foo bar)''.  This avoids the need to use quotes when
     importing symbols.  The actual code generated by
     `-Mmodule=foo,bar' is `use module split(/,/,q{foo,bar})'.  Note
     that the = form removes the distinction between -m and -M.

-n
     causes Perl to assume the following loop around your script, which
     makes it iterate over filename arguments somewhat like *sed -n* or
     *awk*:

          while (<>) {
                  ...             # your script goes here
          }

     Note that the lines are not printed by default.  See -p to have
     lines printed.  Here is an efficient way to delete all files older
     than a week:

          find . -mtime +7 -print | perl -nle 'unlink;'

     This is faster than using the `-exec' switch of *find* because you
     don't have to start a process on every filename found.

     BEGIN and END blocks may be used to capture control before or after
     the implicit loop, just as in *awk*.

-p
     causes Perl to assume the following loop around your script, which
     makes it iterate over filename arguments somewhat like *sed*:

          while (<>) {
                  ...             # your script goes here
          } continue {
                  print;
          }

     Note that the lines are printed automatically.  To suppress
     printing use the -n switch.  A -p overrides a -n switch.

     BEGIN and END blocks may be used to capture control before or after
     the implicit loop, just as in awk.

-P
     causes your script to be run through the C preprocessor before
     compilation by Perl.  (Because both comments and cpp directives
     begin with the # character, you should avoid starting comments
     with any words recognized by the C preprocessor such as "if",
     "else", or "define".)

-s
     enables some rudimentary switch parsing for switches on the command
     line after the script name but before any filename arguments (or
     before a *-*).  Any switch found there is removed from @ARGV and
     sets the corresponding variable in the Perl script.  The following
     script prints "true" if and only if the script is invoked with a
     *-xyz* switch.

          #!/usr/bin/perl -s
          if ($xyz) { print "true\n"; }

-S
     makes Perl use the PATH environment variable to search for the
     script (unless the name of the script starts with a slash).
     Typically this is used to emulate #! startup on machines that
     don't support #!, in the following manner:

          #!/usr/bin/perl
          eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
                      if $running_under_some_shell;

     The system ignores the first line and feeds the script to /bin/sh,
     which proceeds to try to execute the Perl script as a shell script.
     The shell executes the second line as a normal shell command, and
     thus starts up the Perl interpreter.  On some systems $0 doesn't
     always contain the full pathname, so the -S tells Perl to search
     for the script if necessary.  After Perl locates the script, it
     parses the lines and ignores them because the variable
     $running_under_some_shell is never true.  A better construct than
     $* would be `${1+"$@"}', which handles embedded spaces and such in
     the filenames, but doesn't work if the script is being interpreted
     by csh.  To start up sh rather than csh, some systems may have to
     replace the #! line with a line containing just a colon, which
     will be politely ignored by Perl.  Other systems can't control
     that, and need a totally devious construct that will work under
     any of csh, sh, or Perl, such as the following:

          eval '(exit $?0)' && eval 'exec /usr/bin/perl -S $0 ${1+"$@"}'
          & eval 'exec /usr/bin/perl -S $0 $argv:q'
                  if $running_under_some_shell;

-T
     forces "taint" checks to be turned on so you can test them.
     Ordinarily these checks are done only when running setuid or
     setgid.  It's a good idea to turn them on explicitly for programs
     run on another's behalf, such as CGI programs.  See *Note Perlsec:
     perlsec.

-u
     causes Perl to dump core after compiling your script.  You can then
     take this core dump and turn it into an executable file by using
     the *undump* program (not supplied).  This speeds startup at the
     expense of some disk space (which you can minimize by stripping
     the executable).  (Still, a "hello world" executable comes out to
     about 200K on my machine.)  If you want to execute a portion of
     your script before dumping, use the dump() operator instead.
     Note: availability of *undump* is platform specific and may not be
     available for a specific port of Perl.

-U
     allows Perl to do unsafe operations.  Currently the only "unsafe"
     operations are the unlinking of directories while running as
     superuser, and running setuid programs with fatal taint checks
     turned into warnings.

-v
     prints the version and patchlevel of your Perl executable.

-V
     prints summary of the major perl configuration values and the
     current value of @INC.

*-V:**name*
     Prints to STDOUT the value of the named configuration variable.

-w
     prints warnings about variable names that are mentioned only once,
     and scalar variables that are used before being set.  Also warns
     about redefined subroutines, and references to undefined
     filehandles or filehandles opened read-only that you are
     attempting to write on.  Also warns you if you use values as a
     number that doesn't look like numbers, using an array as though it
     were a scalar, if your subroutines recurse more than 100 deep, and
     innumerable other things.

     You can disable specific warnings using `__WARN__' hooks, as
     described in *Note Perlvar: perlvar, and `warn', *Note Perlfunc:
     perlfunc,. See also `warn', *Note Perldiag: perldiag, and `warn',
     *Note Perltrap: perltrap,.

-x *directory*
     tells Perl that the script is embedded in a message.  Leading
     garbage will be discarded until the first line that starts with #!
     and contains the string "perl".  Any meaningful switches on that
     line will be applied.  If a directory name is specified, Perl will
     switch to that directory before running the script.  The -x switch
     controls only the disposal of leading garbage.  The script must be
     terminated with `__END__' if there is trailing garbage to be
     ignored (the script can process any or all of the trailing garbage
     via the DATA filehandle if desired).

ENVIRONMENT
===========

HOME
     Used if chdir has no argument.

LOGDIR
     Used if chdir has no argument and HOME is not set.

PATH
     Used in executing subprocesses, and in finding the script if -S is
     used.

PERL5LIB
     A colon-separated list of directories in which to look for Perl
     library files before looking in the standard library and the
     current directory.  If PERL5LIB is not defined, PERLLIB is used.
     When running taint checks (because the script was running setuid
     or setgid, or the -T switch was used), neither variable is used.
     The script should instead say

          use lib "/my/directory";

PERL5OPT
     Command-line options (switches).  Switches in this variable are
     taken as if they were on every Perl command line.  Only the
     *-[DIMUdmw]* switches are allowed.  When running taint checks
     (because the script was running setuid or setgid, or the -T switch
     was used), this variable is ignored.

PERLLIB
     A colon-separated list of directories in which to look for Perl
     library files before looking in the standard library and the
     current directory.  If PERL5LIB is defined, PERLLIB is not used.

PERL5DB
     The command used to load the debugger code.  The default is:

          BEGIN { require 'perl5db.pl' }

PERL_DEBUG_MSTATS
     Relevant only if your perl executable was built with
     *-DDEBUGGING_MSTATS*, if set, this causes memory statistics to be
     dumped after execution.  If set to an integer greater than one,
     also causes memory statistics to be dumped after compilation.

PERL_DESTRUCT_LEVEL
     Relevant only if your perl executable was built with *-DDEBUGGING*,
     this controls the behavior of global destruction of objects and
     other references.

Perl also has environment variables that control how Perl handles data
specific to particular natural languages.  See *Note Perllocale:
perllocale.

Apart from these, Perl uses no other environment variables, except to
make them available to the script being executed, and to child
processes.  However, scripts running setuid would do well to execute
the following lines before doing anything else, just to keep people
honest:

     $ENV{PATH} = '/bin:/usr/bin';    # or whatever you need
     $ENV{SHELL} = '/bin/sh' if exists $ENV{SHELL};
     delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};

