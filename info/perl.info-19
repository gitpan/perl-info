This is Info file perl.info, produced by Makeinfo-1.64 from the input
file Pmaster.texi.


File: perl.info,  Node: perlref,  Next: perldsc,  Prev: perllocale,  Up: Top

NAME
====

perlref - Perl references and nested data structures

DESCRIPTION
===========

Before release 5 of Perl it was difficult to represent complex data
structures, because all references had to be symbolic, and even that was
difficult to do when you wanted to refer to a variable rather than a
symbol table entry.  Perl not only makes it easier to use symbolic
references to variables, but lets you have "hard" references to any
piece of data.  Any scalar may hold a hard reference.  Because arrays
and hashes contain scalars, you can now easily build arrays of arrays,
arrays of hashes, hashes of arrays, arrays of hashes of functions, and
so on.

Hard references are smart-they keep track of reference counts for you,
automatically freeing the thing referred to when its reference count
goes to zero.  (Note: The reference counts for values in
self-referential or cyclic data structures may not go to zero without a
little help; see `"Two-Phased Garbage Collection"', *Note Perlobj:
perlobj, for a detailed explanation.  If that thing happens to be an
object, the object is destructed.  See `"Two-Phased Garbage
Collection"', *Note Perlobj: perlobj, for more about objects.  (In a
sense, everything in Perl is an object, but we usually reserve the word
for references to objects that have been officially "blessed" into a
class package.)

Symbolic references are names of variables or other objects, just as a
symbolic link in a Unix filesystem contains merely the name of a file.
The `*glob' notation is a kind of symbolic reference.  (Symbolic
references are sometimes called "soft references", but please don't call
them that; references are confusing enough without useless synonyms.)

In contrast, hard references are more like hard links in a Unix file
system: They are used to access an underlying object without concern for
what its (other) name is.  When the word "reference" is used without an
adjective, like in the following paragraph, it usually is talking about
a hard reference.

References are easy to use in Perl.  There is just one overriding
principle: Perl does no implicit referencing or dereferencing.  When a
scalar is holding a reference, it always behaves as a simple scalar.  It
doesn't magically start being an array or hash or subroutine; you have
to tell it explicitly to do so, by dereferencing it.

References can be constructed in several ways.

  1. By using the backslash operator on a variable, subroutine, or
     value.  (This works much like the & (address-of) operator in C.)
     Note that this typically creates *ANOTHER* reference to a
     variable, because there's already a reference to the variable in
     the symbol table.  But the symbol table reference might go away,
     and you'll still have the reference that the backslash returned.
     Here are some examples:

          $scalarref = \$foo;
          $arrayref  = \@ARGV;
          $hashref   = \%ENV;
          $coderef   = \&handler;
          $globref   = \*foo;

     It isn't possible to create a true reference to an IO handle
     (filehandle or dirhandle) using the backslash operator.  See the
     explanation of the *foo{THING} syntax below.  (However, you're apt
     to find Perl code out there using globrefs as though they were IO
     handles, which is grandfathered into continued functioning.)

  2. A reference to an anonymous array can be constructed using square
     brackets:

          $arrayref = [1, 2, ['a', 'b', 'c']];

     Here we've constructed a reference to an anonymous array of three
     elements whose final element is itself a reference to another
     anonymous array of three elements.  (The multidimensional syntax
     described later can be used to access this.  For example, after
     the above, C<$arrayref->[2][1]> would have the value "b".)

     Note that taking a reference to an enumerated list is not the same
     as using square brackets-instead it's the same as creating a list
     of references!

          @list = (\$a, \@b, \%c);
          @list = \($a, @b, %c);        # same thing!

     As a special case, `\(@foo)' returns a list of references to the
     contents of `@foo', not a reference to `@foo' itself.  Likewise
     for `%foo'.

  3. A reference to an anonymous hash can be constructed using curly
     brackets:

          $hashref = {
                  'Adam'  => 'Eve',
                  'Clyde' => 'Bonnie',
          };

     Anonymous hash and array constructors can be intermixed freely to
     produce as complicated a structure as you want.  The
     multidimensional syntax described below works for these too.  The
     values above are literals, but variables and expressions would
     work just as well, because assignment operators in Perl (even
     within local() or my()) are executable statements, not
     compile-time declarations.

     Because curly brackets (braces) are used for several other things
     including BLOCKs, you may occasionally have to disambiguate braces
     at the beginning of a statement by putting a `+' or a return in
     front so that Perl realizes the opening brace isn't starting a
     BLOCK.  The economy and mnemonic value of using curlies is deemed
     worth this occasional extra hassle.

     For example, if you wanted a function to make a new hash and
     return a reference to it, you have these options:

          sub hashem {        { @_ } }   # silently wrong
          sub hashem {       +{ @_ } }   # ok
          sub hashem { return { @_ } }   # ok

  4. A reference to an anonymous subroutine can be constructed by using
     sub without a subname:

          $coderef = sub { print "Boink!\n" };

     Note the presence of the semicolon.  Except for the fact that the
     code inside isn't executed immediately, a `sub {}' is not so much a
     declaration as it is an operator, like `do{}' or `eval{}'.
     (However, no matter how many times you execute that line (unless
     you're in an `eval("...")'), `$coderef' will still have a
     reference to the *SAME* anonymous subroutine.)

     Anonymous subroutines act as closures with respect to my()
     variables, that is, variables visible lexically within the current
     scope.  Closure is a notion out of the Lisp world that says if you
     define an anonymous function in a particular lexical context, it
     pretends to run in that context even when it's called outside of
     the context.

     In human terms, it's a funny way of passing arguments to a
     subroutine when you define it as well as when you call it.  It's
     useful for setting up little bits of code to run later, such as
     callbacks.  You can even do object-oriented stuff with it, though
     Perl already provides a different mechanism to do that-see *Note
     Perlobj: perlobj.

     You can also think of closure as a way to write a subroutine
     template without using eval.  (In fact, in version 5.000, eval was
     the *only* way to get closures.  You may wish to use "require
     5.001" if you use closures.)

     Here's a small example of how closures works:

          sub newprint {
                  my $x = shift;
                  return sub { my $y = shift; print "$x, $y!\n"; };
          }
          $h = newprint("Howdy");
          $g = newprint("Greetings");
          
          # Time passes...
          
          &$h("world");
          &$g("earthlings");

     This prints

          Howdy, world!
          Greetings, earthlings!

     Note particularly that $x continues to refer to the value passed
     into newprint() *despite* the fact that the "my $x" has seemingly
     gone out of scope by the time the anonymous subroutine runs.
     That's what closure is all about.

     This applies to only lexical variables, by the way.  Dynamic
     variables continue to work as they have always worked.  Closure is
     not something that most Perl programmers need trouble themselves
     about to begin with.

  5. References are often returned by special subroutines called
     constructors.  Perl objects are just references to a special kind
     of object that happens to know which package it's associated with.
     Constructors are just special subroutines that know how to create
     that association.  They do so by starting with an ordinary
     reference, and it remains an ordinary reference even while it's
     also being an object.  Constructors are customarily named new(),
     but don't have to be:

          $objref = new Doggie (Tail => 'short', Ears => 'long');

  6. References of the appropriate type can spring into existence if you
     dereference them in a context that assumes they exist.  Because we
     haven't talked about dereferencing yet, we can't show you any
     examples yet.

  7. A reference can be created by using a special syntax, lovingly
     known as the *foo{THING} syntax.  *foo{THING} returns a reference
     to the THING slot in *foo (which is the symbol table entry which
     holds everything known as foo).

          $scalarref = *foo{SCALAR};
          $arrayref  = *ARGV{ARRAY};
          $hashref   = *ENV{HASH};
          $coderef   = *handler{CODE};
          $ioref     = *STDIN{IO};
          $globref   = *foo{GLOB};

     All of these are self-explanatory except for *foo{IO}.  It returns
     the IO handle, used for file handles (`open', *Note Perlfunc:
     perlfunc,), sockets (`socket', *Note Perlfunc: perlfunc, and
     `socketpair', *Note Perlfunc: perlfunc,), and directory handles
     (`opendir', *Note Perlfunc: perlfunc,).  For compatibility with
     previous versions of Perl, *foo{FILEHANDLE} is a synonym for
     *foo{IO}.

     *foo{THING} returns undef if that particular THING hasn't been
     used yet, except in the case of scalars.  *foo{SCALAR} returns a
     reference to an anonymous scalar if $foo hasn't been used yet.
     This might change in a future release.

     The use of *foo{IO} is the best way to pass bareword filehandles
     into or out of subroutines, or to store them in larger data
     structures.

          splutter(*STDOUT{IO});
          sub splutter {
                  my $fh = shift;
                  print $fh "her um well a hmmm\n";
          }
          
          $rec = get_rec(*STDIN{IO});
          sub get_rec {
                  my $fh = shift;
                  return scalar <$fh>;
          }

     Beware, though, that you can't do this with a routine which is
     going to open the filehandle for you, because *HANDLE{IO} will be
     undef if HANDLE hasn't been used yet.  Use \*HANDLE for that sort
     of thing instead.

     Using \*HANDLE (or *HANDLE) is another way to use and store
     non-bareword filehandles (before perl version 5.002 it was the
     only way).  The two methods are largely interchangeable, you can do

          splutter(\*STDOUT);
          $rec = get_rec(\*STDIN);

     with the above subroutine definitions.

     That's it for creating references.  By now you're probably dying to
know how to use references to get back to your long-lost data.  There
are several basic methods.

  1. Anywhere you'd put an identifier (or chain of identifiers) as part
     of a variable or subroutine name, you can replace the identifier
     with a simple scalar variable containing a reference of the
     correct type:

          $bar = $$scalarref;
          push(@$arrayref, $filename);
          $$arrayref[0] = "January";
          $$hashref{"KEY"} = "VALUE";
          &$coderef(1,2,3);
          print $globref "output\n";

     It's important to understand that we are specifically *NOT*
     dereferencing `$arrayref[0]' or `$hashref{"KEY"}' there.  The
     dereference of the scalar variable happens *BEFORE* it does any
     key lookups.  Anything more complicated than a simple scalar
     variable must use methods 2 or 3 below.  However, a "simple
     scalar" includes an identifier that itself uses method 1
     recursively.  Therefore, the following prints "howdy".

          $refrefref = \\\"howdy";
          print $$$$refrefref;

  2. Anywhere you'd put an identifier (or chain of identifiers) as part
     of a variable or subroutine name, you can replace the identifier
     with a BLOCK returning a reference of the correct type.  In other
     words, the previous examples could be written like this:

          $bar = ${$scalarref};
          push(@{$arrayref}, $filename);
          ${$arrayref}[0] = "January";
          ${$hashref}{"KEY"} = "VALUE";
          &{$coderef}(1,2,3);
          $globref->print("output\n");  # iff IO::Handle is loaded

     Admittedly, it's a little silly to use the curlies in this case,
     but the BLOCK can contain any arbitrary expression, in particular,
     subscripted expressions:

          &{ $dispatch{$index} }(1,2,3);      # call correct routine

     Because of being able to omit the curlies for the simple case of
     `$$x', people often make the mistake of viewing the dereferencing
     symbols as proper operators, and wonder about their precedence.
     If they were, though, you could use parentheses instead of braces.
     That's not the case.  Consider the difference below; case 0 is a
     short-hand version of case 1, *NOT* case 2:

          $$hashref{"KEY"}   = "VALUE";         # CASE 0
          ${$hashref}{"KEY"} = "VALUE";       # CASE 1
          ${$hashref{"KEY"}} = "VALUE";       # CASE 2
          ${$hashref->{"KEY"}} = "VALUE";     # CASE 3

     Case 2 is also deceptive in that you're accessing a variable
     called %hashref, not dereferencing through $hashref to the hash
     it's presumably referencing.  That would be case 3.

  3. Subroutine calls and lookups of individual array elements arise
     often enough that it gets cumbersome to use method 2.  As a form of
     syntactic sugar, the examples for method 2 may be written:

          $arrayref->[0] = "January";   # Array element
          $hashref->{"KEY"} = "VALUE";  # Hash element
          $coderef->(1,2,3);            # Subroutine call

     The left side of the arrow can be any expression returning a
     reference, including a previous dereference.  Note that
     `$array[$x]' is *NOT* the same thing as C<$array->[$x]> here:

          $array[$x]->{"foo"}->[0] = "January";

     This is one of the cases we mentioned earlier in which references
     could spring into existence when in an lvalue context.  Before this
     statement, `$array[$x]' may have been undefined.  If so, it's
     automatically defined with a hash reference so that we can look up
     `{"foo"}' in it.  Likewise C<$array[$x]->{"foo"}> will
     automatically get defined with an array reference so that we can
     look up `[0]' in it.

     One more thing here.  The arrow is optional *BETWEEN* brackets
     subscripts, so you can shrink the above down to

          $array[$x]{"foo"}[0] = "January";

     Which, in the degenerate case of using only ordinary arrays, gives
     you multidimensional arrays just like C's:

          $score[$x][$y][$z] += 42;

     Well, okay, not entirely like C's arrays, actually.  C doesn't
     know how to grow its arrays on demand.  Perl does.

  4. If a reference happens to be a reference to an object, then there
     are probably methods to access the things referred to, and you
     should probably stick to those methods unless you're in the class
     package that defines the object's methods.  In other words, be
     nice, and don't violate the object's encapsulation without a very
     good reason.  Perl does not enforce encapsulation.  We are not
     totalitarians here.  We do expect some basic civility though.

     The ref() operator may be used to determine what type of thing the
reference is pointing to.  See *Note Perlfunc: perlfunc.

The bless() operator may be used to associate a reference with a package
functioning as an object class.  See *Note Perlobj: perlobj.

A typeglob may be dereferenced the same way a reference can, because
the dereference syntax always indicates the kind of reference desired.
So `${*foo}' and `${\$foo}' both indicate the same scalar variable.

Here's a trick for interpolating a subroutine call into a string:

     print "My sub returned @{[mysub(1,2,3)]} that time.\n";

The way it works is that when the `@{...}' is seen in the double-quoted
string, it's evaluated as a block.  The block creates a reference to an
anonymous array containing the results of the call to `mysub(1,2,3)'.
So the whole block returns a reference to an array, which is then
dereferenced by `@{...}' and stuck into the double-quoted string. This
chicanery is also useful for arbitrary expressions:

     print "That yields @{[$n + 5]} widgets\n";

Symbolic references
-------------------

We said that references spring into existence as necessary if they are
undefined, but we didn't say what happens if a value used as a
reference is already defined, but *ISN'T* a hard reference.  If you use
it as a reference in this case, it'll be treated as a symbolic
reference.  That is, the value of the scalar is taken to be the NAME of
a variable, rather than a direct link to a (possibly) anonymous value.

People frequently expect it to work like this.  So it does.

     $name = "foo";
     $$name = 1;                     # Sets $foo
     ${$name} = 2;         # Sets $foo
     ${$name x 2} = 3;             # Sets $foofoo
     $name->[0] = 4;         # Sets $foo[0]
     @$name = ();           # Clears @foo
     &$name();                       # Calls &foo() (as in Perl 4)
     $pack = "THAT";
     ${"${pack}::$name"} = 5;    # Sets $THAT::foo without eval

This is very powerful, and slightly dangerous, in that it's possible to
intend (with the utmost sincerity) to use a hard reference, and
accidentally use a symbolic reference instead.  To protect against
that, you can say

     use strict 'refs';

and then only hard references will be allowed for the rest of the
enclosing block.  An inner block may countermand that with

     no strict 'refs';

Only package variables are visible to symbolic references.  Lexical
variables (declared with my()) aren't in a symbol table, and thus are
invisible to this mechanism.  For example:

     local($value) = 10;
     $ref = \$value;
     {
             my $value = 20;
             print $$ref;
     }

This will still print 10, not 20.  Remember that local() affects package
variables, which are all "global" to the package.

Not-so-symbolic references
--------------------------

A new feature contributing to readability in perl version 5.001 is that
the brackets around a symbolic reference behave more like quotes, just
as they always have within a string.  That is,

     $push = "pop on ";
     print "${push}over";

has always meant to print "pop on over", despite the fact that push is
a reserved word.  This has been generalized to work the same outside of
quotes, so that

     print ${push} . "over";

and even

     print ${ push } . "over";

will have the same effect.  (This would have been a syntax error in
Perl 5.000, though Perl 4 allowed it in the spaceless form.)  Note that
this construct is *not* considered to be a symbolic reference when
you're using strict refs:

     use strict 'refs';
     ${ bareword };        # Okay, means $bareword.
     ${ "bareword" };      # Error, symbolic reference.

Similarly, because of all the subscripting that is done using single
words, we've applied the same rule to any bareword that is used for
subscripting a hash.  So now, instead of writing

     $array{ "aaa" }{ "bbb" }{ "ccc" }

you can write just

     $array{ aaa }{ bbb }{ ccc }

and not worry about whether the subscripts are reserved words.  In the
rare event that you do wish to do something like

     $array{ shift }

you can force interpretation as a reserved word by adding anything that
makes it more than a bareword:

     $array{ shift() }
     $array{ +shift }
     $array{ shift @_ }

The -w switch will warn you if it interprets a reserved word as a
string.  But it will no longer warn you about using lowercase words,
because the string is effectively quoted.

WARNING
=======

You may not (usefully) use a reference as the key to a hash.  It will be
converted into a string:

     $x{ \$a } = $a;

If you try to dereference the key, it won't do a hard dereference, and
you won't accomplish what you're attempting.  You might want to do
something more like

     $r = \@a;
     $x{ $r } = $r;

And then at least you can use the values(), which will be real refs,
instead of the keys(), which won't.

SEE ALSO
========

Besides the obvious documents, source code can be instructive.  Some
rather pathological examples of the use of references can be found in
the `t/op/ref.t' regression test in the Perl source directory.

See also *Note Perldsc: perldsc, and *Note Perllol: perllol, for how to
use references to create complex data structures, and *Note Perlobj:
perlobj, for how to use them to create objects.


File: perl.info,  Node: perldsc,  Next: perllol,  Prev: perlref,  Up: Top

NAME
====

perldsc - Perl Data Structures Cookbook

DESCRIPTION
===========

The single feature most sorely lacking in the Perl programming language
prior to its 5.0 release was complex data structures.  Even without
direct language support, some valiant programmers did manage to emulate
them, but it was hard work and not for the faint of heart.  You could
occasionally get away with the `$m{$LoL,$b}' notation borrowed from
*awk* in which the keys are actually more like a single concatenated
string `"$LoL$b"', but traversal and sorting were difficult.  More
desperate programmers even hacked Perl's internal symbol table
directly, a strategy that proved hard to develop and maintain-to put it
mildly.

The 5.0 release of Perl let us have complex data structures.  You may
now write something like this and all of a sudden, you'd have a array
with three dimensions!

     for $x (1 .. 10) {
             for $y (1 .. 10) {
                 for $z (1 .. 10) {
                     $LoL[$x][$y][$z] =
                         $x ** $y + $z;
                 }
             }
     }

Alas, however simple this may appear, underneath it's a much more
elaborate construct than meets the eye!

How do you print it out?  Why can't you say just `print @LoL'?  How do
you sort it?  How can you pass it to a function or get one of these back
from a function?  Is is an object?  Can you save it to disk to read
back later?  How do you access whole rows or columns of that matrix?  Do
all the values have to be numeric?

As you see, it's quite easy to become confused.  While some small
portion of the blame for this can be attributed to the reference-based
implementation, it's really more due to a lack of existing
documentation with examples designed for the beginner.

This document is meant to be a detailed but understandable treatment of
the many different sorts of data structures you might want to develop.
It should also serve as a cookbook of examples.  That way, when you
need to create one of these complex data structures, you can just
pinch, pilfer, or purloin a drop-in example from here.

Let's look at each of these possible constructs in detail.  There are
separate sections on each of the following:

   * arrays of arrays

   * hashes of arrays

   * arrays of hashes

   * hashes of hashes

   * more elaborate constructs

But for now, let's look at some of the general issues common to all of
these types of data structures.

REFERENCES
==========

The most important thing to understand about all data structures in Perl
- including multidimensional arrays-is that even though they might
appear otherwise, Perl `@ARRAY's and `%HASH'es are all internally
one-dimensional.  They can hold only scalar values (meaning a string,
number, or a reference).  They cannot directly contain other arrays or
hashes, but instead contain *references* to other arrays or hashes.

You can't use a reference to a array or hash in quite the same way that
you would a real array or hash.  For C or C++ programmers unused to
distinguishing between arrays and pointers to the same, this can be
confusing.  If so, just think of it as the difference between a
structure and a pointer to a structure.

You can (and should) read more about references in the perlref(1) man
page.  Briefly, references are rather like pointers that know what they
point to.  (Objects are also a kind of reference, but we won't be
needing them right away-if ever.)  This means that when you have
something which looks to you like an access to a
two-or-more-dimensional array and/or hash, what's really going on is
that the base type is merely a one-dimensional entity that contains
references to the next level.  It's just that you can use it as though
it were a two-dimensional one.  This is actually the way almost all C
multidimensional arrays work as well.

     $list[7][12]                    # array of arrays
     $list[7]{string}                      # array of hashes
     $hash{string}[7]                      # hash of arrays
     $hash{string}{'another string'}   # hash of hashes

Now, because the top level contains only references, if you try to print
out your array in with a simple print() function, you'll get something
that doesn't look very nice, like this:

     @LoL = ( [2, 3], [4, 5, 7], [0] );
     print $LoL[1][2];
       7
     print @LoL;
       ARRAY(0x83c38)ARRAY(0x8b194)ARRAY(0x8b1d0)

That's because Perl doesn't (ever) implicitly dereference your
variables.  If you want to get at the thing a reference is referring
to, then you have to do this yourself using either prefix typing
indicators, like `${$blah}', `@{$blah}', `@{$blah[$i]}', or else
postfix pointer arrows, like C<$a->[3]>, C<$h->{fred}>, or even
C<$ob->method()->[3]>.

COMMON MISTAKES
===============

The two most common mistakes made in constructing something like an
array of arrays is either accidentally counting the number of elements
or else taking a reference to the same memory location repeatedly.
Here's the case where you just get the count instead of a nested array:

     for $i (1..10) {
             @list = somefunc($i);
             $LoL[$i] = @list;      # WRONG!
     }

That's just the simple case of assigning a list to a scalar and getting
its element count.  If that's what you really and truly want, then you
might do well to consider being a tad more explicit about it, like this:

     for $i (1..10) {
             @list = somefunc($i);
             $counts[$i] = scalar @list;
     }

Here's the case of taking a reference to the same memory location again
and again:

     for $i (1..10) {
             @list = somefunc($i);
             $LoL[$i] = \@list;     # WRONG!
     }

So, what's the big problem with that?  It looks right, doesn't it?
After all, I just told you that you need an array of references, so by
golly, you've made me one!

Unfortunately, while this is true, it's still broken.  All the
references in @LoL refer to the *very same place*, and they will
therefore all hold whatever was last in @list!  It's similar to the
problem demonstrated in the following C program:

     #include <pwd.h>
     main() {
             struct passwd *getpwnam(), *rp, *dp;
             rp = getpwnam("root");
             dp = getpwnam("daemon");
     
     printf("daemon name is %s\nroot name is %s\n",
             dp->pw_name, rp->pw_name);
         }

Which will print

     daemon name is daemon
     root name is daemon

The problem is that both `rp' and `dp' are pointers to the same location
in memory!  In C, you'd have to remember to malloc() yourself some new
memory.  In Perl, you'll want to use the array constructor `[]' or the
hash constructor `{}' instead.   Here's the right way to do the
preceding broken code fragments:

     for $i (1..10) {
             @list = somefunc($i);
             $LoL[$i] = [ @list ];
     }

The square brackets make a reference to a new array with a *copy* of
what's in @list at the time of the assignment.  This is what you want.

Note that this will produce something similar, but it's much harder to
read:

     for $i (1..10) {
             @list = 0 .. $i;
             @{$LoL[$i]} = @list;
     }

Is it the same?  Well, maybe so-and maybe not.  The subtle difference
is that when you assign something in square brackets, you know for sure
it's always a brand new reference with a new *copy* of the data.
Something else could be going on in this new case with the
`@{$LoL[$i]}}' dereference on the left-hand-side of the assignment.  It
all depends on whether `$LoL[$i]' had been undefined to start with, or
whether it already contained a reference.  If you had already populated
@LoL with references, as in

     $LoL[3] = \@another_list;

Then the assignment with the indirection on the left-hand-side would
use the existing reference that was already there:

     @{$LoL[3]} = @list;

Of course, this *would* have the "interesting" effect of clobbering
@another_list.  (Have you ever noticed how when a programmer says
something is "interesting", that rather than meaning "intriguing",
they're disturbingly more apt to mean that it's "annoying",
"difficult", or both?  :-)

So just remember always to use the array or hash constructors with `[]'
or `{}', and you'll be fine, although it's not always optimally
efficient.

Surprisingly, the following dangerous-looking construct will actually
work out fine:

     for $i (1..10) {
         my @list = somefunc($i);
         $LoL[$i] = \@list;
     }

That's because my() is more of a run-time statement than it is a
compile-time declaration *per se*.  This means that the my() variable is
remade afresh each time through the loop.  So even though it *looks* as
though you stored the same variable reference each time, you actually
did not!  This is a subtle distinction that can produce more efficient
code at the risk of misleading all but the most experienced of
programmers.  So I usually advise against teaching it to beginners.  In
fact, except for passing arguments to functions, I seldom like to see
the gimme-a-reference operator (backslash) used much at all in code.
Instead, I advise beginners that they (and most of the rest of us)
should try to use the much more easily understood constructors `[]' and
`{}' instead of relying upon lexical (or dynamic) scoping and hidden
reference-counting to do the right thing behind the scenes.

In summary:

     $LoL[$i] = [ @list ];  # usually best
     $LoL[$i] = \@list;             # perilous; just how my() was that list?
     @{ $LoL[$i] } = @list;      # way too tricky for most programmers

CAVEAT ON PRECEDENCE
====================

Speaking of things like `@{$LoL[$i]}', the following are actually the
same thing:

     $listref->[2][2]        # clear
     $$listref[2][2] # confusing

That's because Perl's precedence rules on its five prefix dereferencers
(which look like someone swearing: `$ @ * % &') make them bind more
tightly than the postfix subscripting brackets or braces!  This will no
doubt come as a great shock to the C or C++ programmer, who is quite
accustomed to using `*a[i]' to mean what's pointed to by the *i'th*
element of a.  That is, they first take the subscript, and only then
dereference the thing at that subscript.  That's fine in C, but this
isn't C.

The seemingly equivalent construct in Perl, `$$listref[$i]' first does
the deref of `$listref', making it take $listref as a reference to an
array, and then dereference that, and finally tell you the *i'th* value
of the array pointed to by $LoL. If you wanted the C notion, you'd have
to write `${$LoL[$i]}' to force the `$LoL[$i]' to get evaluated first
before the leading `$' dereferencer.

WHY YOU SHOULD ALWAYS `use strict'
==================================

If this is starting to sound scarier than it's worth, relax.  Perl has
some features to help you avoid its most common pitfalls.  The best way
to avoid getting confused is to start every program like this:

     #!/usr/bin/perl -w
     use strict;

This way, you'll be forced to declare all your variables with my() and
also disallow accidental "symbolic dereferencing".  Therefore if you'd
done this:

     my $listref = [
             [ "fred", "barney", "pebbles", "bambam", "dino", ],
             [ "homer", "bart", "marge", "maggie", ],
             [ "george", "jane", "elroy", "judy", ],
     ];
     
     print $listref[2][2];

The compiler would immediately flag that as an error *at compile time*,
because you were accidentally accessing `@listref', an undeclared
variable, and it would thereby remind you to write instead:

     print $listref->[2][2]

DEBUGGING
=========

Before version 5.002, the standard Perl debugger didn't do a very nice
job of printing out complex data structures.  With 5.002 or above, the
debugger includes several new features, including command line editing
as well as the x command to dump out complex data structures.  For
example, given the assignment to $LoL above, here's the debugger output:

     DB<1> X $LoL
     $LoL = ARRAY(0x13b5a0)
        0  ARRAY(0x1f0a24)
               0  'fred'
               1  'barney'
               2  'pebbles'
               3  'bambam'
               4  'dino'
        1  ARRAY(0x13b558)
               0  'homer'
               1  'bart'
               2  'marge'
               3  'maggie'
        2  ARRAY(0x13b540)
               0  'george'
               1  'jane'
               2  'elroy'
               3  'judy'

There's also a lowercase x command which is nearly the same.

CODE EXAMPLES
=============

Presented with little comment (these will get their own manpages
someday) here are short code examples illustrating access of various
types of data structures.

LISTS OF LISTS
==============

Declaration of a LIST OF LISTS
------------------------------

     @LoL = (
            [ "fred", "barney" ],
            [ "george", "jane", "elroy" ],
            [ "homer", "marge", "bart" ],
          );

Generation of a LIST OF LISTS
-----------------------------

     # reading from file
     while ( <> ) {
         push @LoL, [ split ];
     }
     
     # calling a function
     for $i ( 1 .. 10 ) {
         $LoL[$i] = [ somefunc($i) ];
     }
     
     # using temp vars
     for $i ( 1 .. 10 ) {
         @tmp = somefunc($i);
         $LoL[$i] = [ @tmp ];
     }
     
     # add to an existing row
     push @{ $LoL[0] }, "wilma", "betty";

Access and Printing of a LIST OF LISTS
--------------------------------------

     # one element
     $LoL[0][0] = "Fred";
     
     # another element
     $LoL[1][1] =~ s/(\w)/\u$1/;
     
     # print the whole thing with refs
     for $aref ( @LoL ) {
         print "\t [ @$aref ],\n";
     }
     
     # print the whole thing with indices
     for $i ( 0 .. $#LoL ) {
         print "\t [ @{$LoL[$i]} ],\n";
     }
     
     # print the whole thing one at a time
     for $i ( 0 .. $#LoL ) {
         for $j ( 0 .. $#{ $LoL[$i] } ) {
             print "elt $i $j is $LoL[$i][$j]\n";
         }
     }

HASHES OF LISTS
===============

Declaration of a HASH OF LISTS
------------------------------

     %HoL = (
            flintstones        => [ "fred", "barney" ],
            jetsons            => [ "george", "jane", "elroy" ],
            simpsons           => [ "homer", "marge", "bart" ],
          );

Generation of a HASH OF LISTS
-----------------------------

     # reading from file
     # flintstones: fred barney wilma dino
     while ( <> ) {
         next unless s/^(.*?):\s*//;
         $HoL{$1} = [ split ];
     }
     
     # reading from file; more temps
     # flintstones: fred barney wilma dino
     while ( $line = <> ) {
         ($who, $rest) = split /:\s*/, $line, 2;
         @fields = split ' ', $rest;
         $HoL{$who} = [ @fields ];
     }
     
     # calling a function that returns a list
     for $group ( "simpsons", "jetsons", "flintstones" ) {
         $HoL{$group} = [ get_family($group) ];
     }
     
     # likewise, but using temps
     for $group ( "simpsons", "jetsons", "flintstones" ) {
         @members = get_family($group);
         $HoL{$group} = [ @members ];
     }
     
     # append new members to an existing family
     push @{ $HoL{"flintstones"} }, "wilma", "betty";

Access and Printing of a HASH OF LISTS
--------------------------------------

     # one element
     $HoL{flintstones}[0] = "Fred";
     
     # another element
     $HoL{simpsons}[1] =~ s/(\w)/\u$1/;
     
     # print the whole thing
     foreach $family ( keys %HoL ) {
         print "$family: @{ $HoL{$family} }\n"
     }
     
     # print the whole thing with indices
     foreach $family ( keys %HoL ) {
         print "family: ";
         foreach $i ( 0 .. $#{ $HoL{$family} } ) {
             print " $i = $HoL{$family}[$i]";
         }
         print "\n";
     }
     
     # print the whole thing sorted by number of members
     foreach $family ( sort { @{$HoL{$b}} <=> @{$HoL{$a}} } keys %HoL ) {
         print "$family: @{ $HoL{$family} }\n"
     }
     
     # print the whole thing sorted by number of members and name
     foreach $family ( sort {
                                 @{$HoL{$b}} <=> @{$HoL{$a}}
                                             ||
                                         $a cmp $b
                 } keys %HoL )
     {
         print "$family: ", join(", ", sort @{ $HoL{$family}), "\n";
     }

LISTS OF HASHES
===============

Declaration of a LIST OF HASHES
-------------------------------

     @LoH = (
            {
                Lead     => "fred",
                Friend   => "barney",
            },
            {
                Lead     => "george",
                Wife     => "jane",
                Son      => "elroy",
            },
            {
                Lead     => "homer",
                Wife     => "marge",
                Son      => "bart",
            }
      );

Generation of a LIST OF HASHES
------------------------------

     # reading from file
     # format: LEAD=fred FRIEND=barney
     while ( <> ) {
         $rec = {};
         for $field ( split ) {
             ($key, $value) = split /=/, $field;
             $rec->{$key} = $value;
         }
         push @LoH, $rec;
     }
     
     # reading from file
     # format: LEAD=fred FRIEND=barney
     # no temp
     while ( <> ) {
         push @LoH, { split /[\s+=]/ };
     }
     
     # calling a function  that returns a key,value list, like
     # "lead","fred","daughter","pebbles"
     while ( %fields = getnextpairset() ) {
         push @LoH, { %fields };
     }
     
     # likewise, but using no temp vars
     while (<>) {
         push @LoH, { parsepairs($_) };
     }
     
     # add key/value to an element
     $LoH[0]{pet} = "dino";
     $LoH[2]{pet} = "santa's little helper";

Access and Printing of a LIST OF HASHES
---------------------------------------

     # one element
     $LoH[0]{lead} = "fred";
     
     # another element
     $LoH[1]{lead} =~ s/(\w)/\u$1/;
     
     # print the whole thing with refs
     for $href ( @LoH ) {
         print "{ ";
         for $role ( keys %$href ) {
             print "$role=$href->{$role} ";
         }
         print "}\n";
     }
     
     # print the whole thing with indices
     for $i ( 0 .. $#LoH ) {
         print "$i is { ";
         for $role ( keys %{ $LoH[$i] } ) {
             print "$role=$LoH[$i]{$role} ";
         }
         print "}\n";
     }
     
     # print the whole thing one at a time
     for $i ( 0 .. $#LoH ) {
         for $role ( keys %{ $LoH[$i] } ) {
             print "elt $i $role is $LoH[$i]{$role}\n";
         }
     }

HASHES OF HASHES
================

Declaration of a HASH OF HASHES
-------------------------------

     %HoH = (
            flintstones => {
                     lead      => "fred",
                     pal       => "barney",
            },
            jetsons     => {
                     lead      => "george",
                     wife      => "jane",
                     "his boy" => "elroy",
            },
            simpsons    => {
                     lead      => "homer",
                     wife      => "marge",
                     kid       => "bart",
             },
     );

Generation of a HASH OF HASHES
------------------------------

     # reading from file
     # flintstones: lead=fred pal=barney wife=wilma pet=dino
     while ( <> ) {
         next unless s/^(.*?):\s*//;
         $who = $1;
         for $field ( split ) {
             ($key, $value) = split /=/, $field;
             $HoH{$who}{$key} = $value;
         }
     
     # reading from file; more temps
     while ( <> ) {
         next unless s/^(.*?):\s*//;
         $who = $1;
         $rec = {};
         $HoH{$who} = $rec;
         for $field ( split ) {
             ($key, $value) = split /=/, $field;
             $rec->{$key} = $value;
         }
     }
     
     # calling a function  that returns a key,value hash
     for $group ( "simpsons", "jetsons", "flintstones" ) {
         $HoH{$group} = { get_family($group) };
     }
     
     # likewise, but using temps
     for $group ( "simpsons", "jetsons", "flintstones" ) {
         %members = get_family($group);
         $HoH{$group} = { %members };
     }
     
     # append new members to an existing family
     %new_folks = (
         wife => "wilma",
         pet  => "dino";
     );
     
     for $what (keys %new_folks) {
         $HoH{flintstones}{$what} = $new_folks{$what};
     }

Access and Printing of a HASH OF HASHES
---------------------------------------

     # one element
     $HoH{flintstones}{wife} = "wilma";
     
     # another element
     $HoH{simpsons}{lead} =~ s/(\w)/\u$1/;
     
     # print the whole thing
     foreach $family ( keys %HoH ) {
         print "$family: { ";
         for $role ( keys %{ $HoH{$family} } ) {
             print "$role=$HoH{$family}{$role} ";
         }
         print "}\n";
     }
     
     # print the whole thing  somewhat sorted
     foreach $family ( sort keys %HoH ) {
         print "$family: { ";
         for $role ( sort keys %{ $HoH{$family} } ) {
             print "$role=$HoH{$family}{$role} ";
         }
         print "}\n";
     }
     
     # print the whole thing sorted by number of members
     foreach $family ( sort { keys %{$HoH{$b}} <=> keys %{$HoH{$a}} } keys %HoH ) {
         print "$family: { ";
         for $role ( sort keys %{ $HoH{$family} } ) {
             print "$role=$HoH{$family}{$role} ";
         }
         print "}\n";
     }
     
     # establish a sort order (rank) for each role
     $i = 0;
     for ( qw(lead wife son daughter pal pet) ) { $rank{$_} = ++$i }
     
     # now print the whole thing sorted by number of members
     foreach $family ( sort { keys %{ $HoH{$b} } <=> keys %{ $HoH{$a} } } keys %HoH ) {
         print "$family: { ";
         # and print these according to rank order
         for $role ( sort { $rank{$a} <=> $rank{$b} }  keys %{ $HoH{$family} } ) {
             print "$role=$HoH{$family}{$role} ";
         }
         print "}\n";
     }

MORE ELABORATE RECORDS
======================

Declaration of MORE ELABORATE RECORDS
-------------------------------------

Here's a sample showing how to create and use a record whose fields are
of many different sorts:

     $rec = {
              TEXT      => $string,
              SEQUENCE  => [ @old_values ],
              LOOKUP    => { %some_table },
              THATCODE  => \&some_function,
              THISCODE  => sub { $_[0] ** $_[1] },
              HANDLE    => \*STDOUT,
     };
     
     print $rec->{TEXT};
     
     print $rec->{LIST}[0];
     $last = pop @ { $rec->{SEQUENCE} };
     
     print $rec->{LOOKUP}{"key"};
     ($first_k, $first_v) = each %{ $rec->{LOOKUP} };
     
     $answer = $rec->{THATCODE}->($arg);
     $answer = $rec->{THISCODE}->($arg1, $arg2);
     
     # careful of extra block braces on fh ref
     print { $rec->{HANDLE} } "a string\n";
     
     use FileHandle;
     $rec->{HANDLE}->autoflush(1);
     $rec->{HANDLE}->print(" a string\n");

Declaration of a HASH OF COMPLEX RECORDS
----------------------------------------

     %TV = (
        flintstones => {
            series   => "flintstones",
            nights   => [ qw(monday thursday friday) ],
            members  => [
                { name => "fred",    role => "lead", age  => 36, },
                { name => "wilma",   role => "wife", age  => 31, },
                { name => "pebbles", role => "kid",  age  =>  4, },
            ],
        },
     
     jetsons     => {
         series   => "jetsons",
         nights   => [ qw(wednesday saturday) ],
         members  => [
             { name => "george",  role => "lead", age  => 41, },
             { name => "jane",    role => "wife", age  => 39, },
             { name => "elroy",   role => "kid",  age  =>  9, },
         ],
      },
     
     simpsons    => {
         series   => "simpsons",
         nights   => [ qw(monday) ],
         members  => [
             { name => "homer", role => "lead", age  => 34, },
             { name => "marge", role => "wife", age => 37, },
             { name => "bart",  role => "kid",  age  =>  11, },
         ],
      },
           );

Generation of a HASH OF COMPLEX RECORDS
---------------------------------------

     # reading from file
     # this is most easily done by having the file itself be
     # in the raw data format as shown above.  perl is happy
     # to parse complex data structures if declared as data, so
     # sometimes it's easiest to do that
     
     # here's a piece by piece build up
     $rec = {};
     $rec->{series} = "flintstones";
     $rec->{nights} = [ find_days() ];
     
     @members = ();
     # assume this file in field=value syntax
     while (<>) {
         %fields = split /[\s=]+/;
         push @members, { %fields };
     }
     $rec->{members} = [ @members ];
     
     # now remember the whole thing
     $TV{ $rec->{series} } = $rec;
     
     ###########################################################
     # now, you might want to make interesting extra fields that
     # include pointers back into the same data structure so if
     # change one piece, it changes everywhere, like for examples
     # if you wanted a {kids} field that was an array reference
     # to a list of the kids' records without having duplicate
     # records and thus update problems.
     ###########################################################
     foreach $family (keys %TV) {
         $rec = $TV{$family}; # temp pointer
         @kids = ();
         for $person ( @{ $rec->{members} } ) {
             if ($person->{role} =~ /kid|son|daughter/) {
                 push @kids, $person;
             }
         }
         # REMEMBER: $rec and $TV{$family} point to same data!!
         $rec->{kids} = [ @kids ];
     }
     
     # you copied the list, but the list itself contains pointers
     # to uncopied objects. this means that if you make bart get
     # older via
     
     $TV{simpsons}{kids}[0]{age}++;
     
     # then this would also change in
     print $TV{simpsons}{members}[2]{age};
     
     # because $TV{simpsons}{kids}[0] and $TV{simpsons}{members}[2]
     # both point to the same underlying anonymous hash table
     
     # print the whole thing
     foreach $family ( keys %TV ) {
         print "the $family";
         print " is on during @{ $TV{$family}{nights} }\n";
         print "its members are:\n";
         for $who ( @{ $TV{$family}{members} } ) {
             print " $who->{name} ($who->{role}), age $who->{age}\n";
         }
         print "it turns out that $TV{$family}{lead} has ";
         print scalar ( @{ $TV{$family}{kids} } ), " kids named ";
         print join (", ", map { $_->{name} } @{ $TV{$family}{kids} } );
         print "\n";
     }

Database Ties
=============

You cannot easily tie a multilevel data structure (such as a hash of
hashes) to a dbm file.  The first problem is that all but GDBM and
Berkeley DB have size limitations, but beyond that, you also have
problems with how references are to be represented on disk.  One
experimental module that does partially attempt to address this need is
the MLDBM module.  Check your nearest CPAN site as described in *Note
Perlmodlib: perlmodlib, for source code to MLDBM.

SEE ALSO
========

perlref(1), perllol(1), perldata(1), perlobj(1)

AUTHOR
======

Tom Christiansen <`tchrist@perl.com'>

Last update: Wed Oct 23 04:57:50 MET DST 1996

